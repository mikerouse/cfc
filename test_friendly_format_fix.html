<!DOCTYPE html>
<html>
<head>
    <title>Test Friendly Format Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/countup@1.9.3/dist/countUp.min.js"></script>
</head>
<body>
    <h1>Testing Friendly Format Fix</h1>
    
    <!-- Test counter with friendly format enabled -->
    <div class="counter-value test-friendly" 
         data-value="1234567"
         data-formatted="£1.2m"
         data-duration="2000"
         data-precision="0"
         data-show-currency="true"
         data-friendly="true">
        £1.2m (should animate to this friendly format)
    </div>
    
    <!-- Test counter with friendly format disabled -->
    <div class="counter-value test-normal" 
         data-value="1234567"
         data-formatted="£1,234,567"
         data-duration="2000"
         data-precision="0"
         data-show-currency="true"
         data-friendly="false">
        £1,234,567 (should animate to this full format)
    </div>

    <script>
    // Copy the functions from our template
    let overridePrecision = null;
    let overrideThousands = null;
    let overrideFriendly = null;

    function formatNumber(value, precision, thousands) {
      let num = Number(value);
      if (thousands) {
        return num.toLocaleString(undefined, {
          minimumFractionDigits: precision,
          maximumFractionDigits: precision
        });
      }
      return num.toFixed(precision);
    }

    function formatValue(value, counter) {
      const showCurrency = (counter.showCurrency || 'false').toLowerCase() === 'true';
      const basePrecision = parseInt(counter.precision || '0', 10);
      const baseFriendly = (counter.friendly || 'false').toLowerCase() === 'true';

      const precision = overridePrecision !== null ? parseInt(overridePrecision, 10) : basePrecision;
      const friendly = overrideFriendly !== null ? (overrideFriendly === 'true') : baseFriendly;
      const thousands = overrideThousands !== null ? (overrideThousands === 'true') : showCurrency;

      let result = '';
      let val = Number(value);
      if (friendly) {
        let suffix = '';
        let displayVal = val;
        const absVal = Math.abs(val);
        if (absVal >= 1e9) { displayVal = val / 1e9; suffix = 'b'; }
        else if (absVal >= 1e6) { displayVal = val / 1e6; suffix = 'm'; }
        else if (absVal >= 1e3) { displayVal = val / 1e3; suffix = 'k'; }
        result = formatNumber(displayVal, precision, thousands) + suffix;
      } else {
        result = formatNumber(val, precision, thousands);
      }
      if (showCurrency) {
        result = '£' + result;
      }
      return result;
    }

    // Our new animateCounters function
    function animateCounters() {
      document.querySelectorAll('.counter-value').forEach(el => {
        if (!el.dataset.value) return;
        const end = parseFloat(el.dataset.value || '0');
        const dur = parseInt(el.dataset.duration || '0') / 1000;
        const display = el.dataset.formatted || end.toLocaleString();
        
        const showCurrency = (el.dataset.showCurrency || 'false').toLowerCase() === 'true';
        const precision = overridePrecision !== null ? parseInt(overridePrecision, 10)
          : parseInt(el.dataset.precision || '0', 10);
        const thousands = overrideThousands !== null ? overrideThousands === 'true'
          : showCurrency;
        
        // Check if friendly format is enabled for this counter
        const baseFriendly = (el.dataset.friendly || 'false').toLowerCase() === 'true';
        const friendly = overrideFriendly !== null ? (overrideFriendly === 'true') : baseFriendly;

        console.log(`Counter: ${el.className}, friendly: ${friendly}, baseFriendly: ${baseFriendly}, dataset.friendly: ${el.dataset.friendly}`);

        // If friendly format is enabled, handle formatting manually after animation
        if (friendly) {
          // For friendly format, use a simplified counter without currency/separator formatting
          // since we'll apply the friendly format manually at the end
          const cu = new countUp.CountUp(el, end, {
            duration: dur,
            decimalPlaces: 0, // Use 0 decimals during animation for cleaner look
            separator: '',     // No separators during animation
            prefix: '',        // No prefix during animation
            easingFn: (t, b, c, d) => {
              t /= d; return c * (2 - t) * t * 0.5 + b;
            }
          });
          
          if (cu.printValue) {
            cu.printValue(0);
          } else {
            el.textContent = cu.formattingFn(0);
          }
          
          if (!cu.error) {
            cu.start(() => {
              // Animation completed - now apply friendly format
              const counter = {
                showCurrency: el.dataset.showCurrency,
                precision: el.dataset.precision,
                friendly: el.dataset.friendly,
              };
              el.textContent = formatValue(end, counter);
              console.log(`Friendly animation completed: ${el.textContent}`);
            });
          } else {
            el.textContent = display;
          }
        } else {
          // Use standard CountUp formatting for non-friendly format
          const cu = new countUp.CountUp(el, end, {
            duration: dur,
            decimalPlaces: precision,
            separator: thousands ? ',' : '',
            prefix: showCurrency ? '£' : '',
            easingFn: (t, b, c, d) => {
              t /= d; return c * (2 - t) * t * 0.5 + b;
            }
          });
          
          if (cu.printValue) {
            cu.printValue(0);
          } else {
            el.textContent = cu.formattingFn(0);
          }
          
          if (!cu.error) {
            cu.start(() => {
              console.log(`Normal animation completed: ${el.textContent}`);
            });
          } else {
            el.textContent = display;
          }
        }
      });
    }

    // Test on page load
    setTimeout(() => {
        console.log('Starting animation test...');
        animateCounters();
    }, 1000);
    </script>
</body>
</html>