"""
Image file model for handling council logo uploads and other image fields.
"""

import os
import hashlib
from django.db import models
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from django.core.files.storage import default_storage
from django.utils import timezone


def validate_image_file(file):
    """Validate uploaded image file type and size."""
    # Check file extension
    allowed_extensions = ['.png', '.jpg', '.jpeg', '.webp', '.svg']
    file_extension = os.path.splitext(file.name)[1].lower()
    
    if file_extension not in allowed_extensions:
        raise ValidationError(f'File type {file_extension} not allowed. Allowed types: {", ".join(allowed_extensions)}')
    
    # Check file size (max 10MB by default)
    max_size = 10 * 1024 * 1024  # 10MB in bytes
    if file.size > max_size:
        raise ValidationError(f'File size {file.size} bytes exceeds maximum allowed size of {max_size} bytes')


def image_upload_path(instance, filename):
    """Generate upload path for image files."""
    # Create a hash of the file to avoid duplicates
    file_hash = hashlib.md5(instance.file.read()).hexdigest()
    instance.file.seek(0)  # Reset file pointer
    
    # Use council slug and field slug for organisation
    council_slug = instance.council.slug if instance.council else 'unknown'
    field_slug = instance.field.slug if instance.field else 'unknown'
    
    # Keep original extension
    _, ext = os.path.splitext(filename)
    
    return f'images/{council_slug}/{field_slug}/{file_hash}{ext}'


class ImageFile(models.Model):
    """
    Stores uploaded image files with metadata and validation.
    Used for council logos and other image fields.
    """
    
    # Basic relationships
    council = models.ForeignKey('Council', on_delete=models.CASCADE, related_name='image_files')
    field = models.ForeignKey('DataField', on_delete=models.CASCADE)
    
    # File and metadata
    file = models.FileField(upload_to=image_upload_path, validators=[validate_image_file])
    original_filename = models.CharField(max_length=255)
    file_size = models.PositiveIntegerField()  # Size in bytes
    width = models.PositiveIntegerField(null=True, blank=True)
    height = models.PositiveIntegerField(null=True, blank=True)
    
    # Image-specific metadata
    alt_text = models.CharField(max_length=255, blank=True, help_text="Alternative text for accessibility")
    copyright_text = models.TextField(blank=True, help_text="Copyright notice or attribution")
    is_ai_generated = models.BooleanField(default=False, help_text="Was this image generated by AI?")
    
    # Upload metadata
    uploaded_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    uploaded_at = models.DateTimeField(auto_now_add=True)
    
    # Status
    is_active = models.BooleanField(default=True, help_text="Whether this image is currently in use")
    is_approved = models.BooleanField(default=False, help_text="Whether this image has been approved for use")
    approved_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name='approved_images')
    approved_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        indexes = [
            models.Index(fields=['council', 'field', 'is_active']),
            models.Index(fields=['is_approved', 'uploaded_at']),
        ]
        ordering = ['-uploaded_at']
        
    def __str__(self):
        return f"{self.council.name} - {self.field.name}: {self.original_filename}"
    
    def save(self, *args, **kwargs):
        """Override save to extract image metadata and validate against field constraints."""
        if self.file:
            # Store original filename
            if not self.original_filename:
                self.original_filename = self.file.name
            
            # Store file size
            self.file_size = self.file.size
            
            # Extract image dimensions (skip for SVG files)
            if not self.file.name.lower().endswith('.svg'):
                try:
                    # Try to import PIL and extract dimensions
                    from PIL import Image
                    with Image.open(self.file) as img:
                        self.width, self.height = img.size
                except ImportError:
                    # PIL not available, skip dimension extraction
                    pass
                except Exception:
                    # If we can't read the image, leave dimensions blank
                    pass
            
            # Validate against field constraints
            self._validate_against_field_constraints()
        
        super().save(*args, **kwargs)
    
    def _validate_against_field_constraints(self):
        """Validate image against DataField constraints."""
        if self.field and self.field.content_type == 'image':
            errors = []
            
            # Check max width
            if self.field.image_max_width and self.width and self.width > self.field.image_max_width:
                errors.append(f'Image width {self.width}px exceeds maximum allowed width of {self.field.image_max_width}px')
            
            # Check max height
            if self.field.image_max_height and self.height and self.height > self.field.image_max_height:
                errors.append(f'Image height {self.height}px exceeds maximum allowed height of {self.field.image_max_height}px')
            
            # Check max file size
            if self.field.image_max_file_size and self.file_size > (self.field.image_max_file_size * 1024):
                errors.append(f'File size {self.file_size} bytes exceeds maximum allowed size of {self.field.image_max_file_size}KB')
            
            if errors:
                raise ValidationError('; '.join(errors))
    
    def get_display_size(self):
        """Return a human-readable file size."""
        if self.file_size < 1024:
            return f"{self.file_size} bytes"
        elif self.file_size < 1024 * 1024:
            return f"{self.file_size / 1024:.1f} KB"
        else:
            return f"{self.file_size / (1024 * 1024):.1f} MB"
    
    def get_dimensions_string(self):
        """Return dimensions as a string."""
        if self.width and self.height:
            return f"{self.width} Ã— {self.height}"
        return "Unknown"
    
    def approve(self, user):
        """Approve this image for use."""
        self.is_approved = True
        self.approved_by = user
        self.approved_at = timezone.now()
        self.save()
    
    def deactivate(self):
        """Deactivate this image (soft delete)."""
        self.is_active = False
        self.save()


class ImageFileHistory(models.Model):
    """
    Track changes to image files over time.
    """
    image_file = models.ForeignKey(ImageFile, on_delete=models.CASCADE, related_name='history')
    
    # What changed
    action = models.CharField(max_length=20, choices=[
        ('uploaded', 'Uploaded'),
        ('approved', 'Approved'),
        ('replaced', 'Replaced'),
        ('deactivated', 'Deactivated'),
        ('metadata_updated', 'Metadata Updated'),
    ])
    
    # Details of the change
    details = models.TextField(blank=True)
    
    # Who and when
    changed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    changed_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-changed_at']
        indexes = [
            models.Index(fields=['image_file', 'changed_at']),
        ]
    
    def __str__(self):
        return f"{self.image_file} - {self.action} at {self.changed_at}"